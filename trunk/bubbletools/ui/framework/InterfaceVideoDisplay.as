// bubbletools.* ===============================================================================// BubbleTools™ Web Application and User Interface Component Architecture for Actionscript 3// ©2007 Michael Szypula.  Any modifications to this file must keep this license block intact.// Developer : Michael Szypula// Contact : michael.szypula@gmail.com// License Information : Contact Developer to obtain license agreement.// =================================================================================================package bubbletools.ui.framework {		import flash.media.Video;	import flash.net.NetStream;	import flash.events.NetStatusEvent;	import bubbletools.ui.interfaces.Reporter;		import flash.display.Sprite;	import bubbletools.util.Pointdata;	import bubbletools.util.MouseEventCapture;	import bubbletools.ui.interfaces.IParameters;	import bubbletools.ui.eventing.*	import bubbletools.ui.framework.*	import bubbletools.ui.parameters.*	import bubbletools.ui.framework.ComponentView;	public class InterfaceVideoDisplay extends InterfaceComponent implements Reporter {			private var parameters:VideoDisplayParameters;		private var videoView:Video;		private var netstream:NetStream;		private var meta:Object;		private var playing:Boolean = false;				private var stopEvent:Boolean = false;		private var emptyEvent:Boolean = false;			public function InterfaceVideoDisplay(parentComponent:InterfaceComponent){			super(parentComponent);			componentType = "VideoDisplay";			allowSubcomponents = false; 		}			//  =====================================================================================================		//  Reporter Implementation		//			public function makeEvent(eventType:String):UIEvent {			var newEvent:UIEvent = UIEventManager.instance().createUIEvent(id, componentType, eventType);			return(newEvent);		}			//  =====================================================================================================		//  Required Override Methods		//			public override function setParameters(newParameters:IParameters):void {			globalParameters = newParameters;			parameters = VideoDisplayParameters(newParameters);		}		public override function displayComponent():void {			videoView = new Video(getParameters().getSize().X, getParameters().getSize().Y);			view.setContents(videoView);		}		public override function handleMouseEvent(clickType:String):void {			switch(clickType) {				case "press" :					bubbleEvent(UIEventType.VIDEO_PRESS);					break;				}		}			//  =====================================================================================================		//  Custom Methods		//		//  Events			public function streamEvent(event:NetStatusEvent):void {					trace(event.info.code);					switch (event.info.code) {				case "NetStream.Play.StreamNotFound":					trace("[VideoDisplay] stream not found");					bubbleEvent(UIEventType.STREAM_ERROR);					break;				case "NetStream.Play.Stop": 					// Set this flag to true since stop may occur up to 2 seconds before the video ends					stopEvent = true;					bubbleEvent(UIEventType.NETSTREAM_PLAY_STOP);										if(emptyEvent) {						emptyEvent = false;						bubbleEvent(UIEventType.VIDEO_COMPLETE);					}					break;				case "NetStream.Buffer.Empty":										emptyEvent = true;					bubbleEvent(UIEventType.BUFFER_EMPTY);										if(stopEvent) {						stopEvent = false;						bubbleEvent(UIEventType.VIDEO_COMPLETE);					} 					break;				case "NetStream.Buffer.Full":					bubbleEvent(UIEventType.BUFFER_FULL);					break;				case "NetStream.Play.Start":					bubbleEvent(UIEventType.NETSTREAM_PLAY_START);					break;				case "NetStream.Play.Complete":					break;				case "NetStream.Seek.Notify":					break;				case "NetStream.Buffer.Flush":					break;				default :					break;		        }				}			public function onMetaData(info:Object):void {					meta = info;					trace("METADATA =========================");			trace("  duration=" + info.duration);			trace("  width=" + info.width);			trace("  height=" + info.height); 			trace("  framerate=" + info.framerate);					bubbleEvent(UIEventType.METADATA_LOADED);		}			public function onPlayStatus(info:Object):void {}			//  Stream information			public function metaData():Object {			return(meta);		}		public function totalTime():Number {			return(meta.duration);		}		public function currentTime():Number {			if (netstream) { 				return(netstream.time);			} else {				return(0);			}		}		//  Controls			public function startVideo(stream:NetStream, videoURL:String):void {			emptyEvent = false;			stopEvent = false;			meta = null;			netstream = stream;			netstream.addEventListener(NetStatusEvent.NET_STATUS, streamEvent);			netstream.client = this;			videoView.attachNetStream(netstream);			netstream.play(videoURL);			playing = true;		}				public function dump():void {			meta = null;			//netstream.removeEventListener(NetStatusEvent.NET_STATUS, streamEvent);			//netstream.client = null;			netstream = null;			playing = false;			stopEvent = false;			emptyEvent = false;		}				public function refresh():void {			meta = null;			videoView = new Video(getParameters().getSize().X, getParameters().getSize().Y);			view.changeContents(videoView);			playing = false;		}		public function pause():void {			if(netstream) {				netstream.pause();			}			playing = false;		}		public function play():void {			netstream.resume()			playing = true;		}		public function end():void {			netstream.seek(totalTime());		}		public function seek(time:Number):void {			trace("Netstream.seek "+time);			netstream.seek(time);		}		public function rewind():void {			trace("Netstream =" + netstream);			netstream.pause();			trace("2");			netstream.seek(0);			trace("3");			playing = false;		}		public function isPlaying():Boolean {			return(playing);		}		}}