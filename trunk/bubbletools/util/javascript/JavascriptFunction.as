// bubbletools.* ===============================================================================// BubbleTools™ Web Application and User Interface Component Architecture for Actionscript 3// ©2007 Michael Szypula.  Any modifications to this file must keep this license block intact.// Developer : Michael Szypula// Contact : michael.szypula@gmail.com// License Information : Contact Developer to obtain license agreement.// =================================================================================================package bubbletools.util.javascript {	import flash.external.ExternalInterface;	import bubbletools.util.Strings;		public class JavascriptFunction {				private var XML_FORMAT;				private var name:String;		private var runtime:String;		private var code:XML;			public function JavascriptFunction(code:XML, xmlFormat:Number) {						XML_FORMAT = xmlFormat;			this.code = code;						var fnString:String;						if(XML_FORMAT == JavascriptFile.XML_SIMPLE) {				fnString = code.attribute("data")			} else if (XML_FORMAT == JavascriptFile.XML_CDATA) {				fnString = code.child(0);			}						var nameStart:Number = fnString.indexOf("function") + 9;			var nameEnd:Number = fnString.indexOf("(");						name = fnString.substr(nameStart, nameEnd-nameStart);			processCode();				}				private function processCode():void {						// Convert to executable JS						if(XML_FORMAT == JavascriptFile.XML_SIMPLE) {				runtime = parseAttributes(code);							} else if (XML_FORMAT == JavascriptFile.XML_CDATA) {								runtime = parseCDATA(code);							}									// Slice off the function name						runtime = runtime.substr(runtime.indexOf("("));						}				private function parseAttributes(jsNode:XML):String {			var str:String = jsNode.attribute("data");			var sub:XMLList = jsNode.children();			if(sub.length() > 0) {				str += "{";				for(var j:Number = 0; j<sub.length(); j++) {					str += parseAttributes(XML(sub[j]));				}			} else {				str += "}";			}			return(str);		}				private function parseCDATA(jsNode:XML):String {			var str:String = jsNode.child(0);			var sub:XMLList = jsNode.children();			if(sub.length() > 0) {				if(parseCDATA(XML(sub[0])) == "" && sub.length()==1) {					// Skip empty nodes				} else {					str += "{";					for(var j:Number = 0; j<sub.length(); j++) {						str += parseCDATA(XML(sub[j]));					}					str += "}";				}			}			return(str);		}				public function fnName():String {			return(name);		}				public function argsList():String {			return(runtime.substr(1, runtime.indexOf(")")-1));		}				public function execute(args:Array):String {						Debug.output(this, "[JavascriptFunction] "+name,args);						// Write the function to the page						ExternalInterface.call("function(){"+name+"=function"+runtime+" }");						// Set up an array to use the "apply" method with -			// Use the first parameter (the js function name) in index 0			// Then fill the rest with the parameters to pass			// Using this method you can pass 1-n parameters and flash will take care of the typing						var parameters:Array = new Array();			parameters[0] = name;			for(var i:Number = 0; i<args.length; i++) {				parameters[i+1] = args[i];			}			var jsReturn:String = String(ExternalInterface.call.apply(ExternalInterface, parameters));					return(jsReturn);		}			}}