// bubbletools.* ===============================================================================// BubbleTools™ Web Application and User Interface Component Architecture for Actionscript 3// ©2007 Michael Szypula.  Any modifications to this file must keep this license block intact.// Developer : Michael Szypula// Contact : michael.szypula@gmail.com// License Information : Contact Developer to obtain license agreement.// =================================================================================================package bubbletools.util.javascript {		import bubbletools.util.Strings;	public class JavascriptParser {				public function JavascriptParser(){}				//  Normalizes a JS script into an XML object				public static function parse(jscode:String, xmlFormat:Number):XML {					var i:Number;			var j:Number;					var jsXMLStr:String = "<javascript>";			jsXMLStr += Strings.lineBreak;						var nesting:Number = 1;						jscode = " "+jscode;						// Remove linebreaks (code /n)						jscode = Strings.toSingleLine(jscode);						var xml:String = JavascriptParser.toNodeTree(jscode, "{", "}", xmlFormat);			jsXMLStr += "</javascript>";						var jsXML:XML = new XML("<javascript>"+xml+"</javascript>");						return(XML(jsXML));		}				private static function toNodeTree(data:String, open:String, close:String, xmlFormat:Number):String {						var q = String.fromCharCode(34);						if(xmlFormat == JavascriptFile.XML_SIMPLE) {							var TAG_START:String = "<jsnode data="+q;				var TAG_OPEN_END:String = q+">";				var TAG_CLOSE_END:String = q+"/>";				var NODE_END:String = "</jsnode>"						} else if (xmlFormat == JavascriptFile.XML_CDATA) {								var TAG_START:String = "<jsnode><![CDATA[";				var TAG_OPEN_END:String = "]]>";				var TAG_CLOSE_END:String = "]]></jsnode>";				var NODE_END:String = "</jsnode>";						}					var firstOpen:Number = data.indexOf(open);			var firstClose:Number = data.indexOf(close);			var lastOpen:Number = data.lastIndexOf(open);			var lastClose:Number = data.lastIndexOf(close);			var xml:String = "";						if((firstOpen != -1)) {								if(lastClose != -1) {									if(firstClose < firstOpen) {											var localData:String = data.substr(0, firstClose);						localData = Strings.removeLeading(localData);						localData = Strings.removeTrailing(localData);						xml = TAG_START+localData+TAG_CLOSE_END+NODE_END;						var nodeData:String = data.substr(firstClose+1);						xml += toNodeTree(nodeData, open, close, xmlFormat);										} else {											var localData:String = data.substr(0,firstOpen);						localData = Strings.removeLeading(localData);						localData = Strings.removeTrailing(localData);						xml = TAG_START+localData+TAG_OPEN_END;						var nodeData:String = data.substr(firstOpen+1,lastClose+1);						xml += toNodeTree(nodeData, open, close, xmlFormat);									}							}							} else {								if(lastClose != -1) {										// Tail end nodes								var localData:String = data.substr(0, firstClose);					localData = Strings.removeLeading(localData);					localData = Strings.removeTrailing(localData);					xml = TAG_START+localData+TAG_CLOSE_END+NODE_END;					var nodeData:String = data.substr(firstClose+1);					xml += toNodeTree(nodeData, open, close, xmlFormat);								} else {								// trace("No pair of "+open,close+" found in " + data);									}						}			return xml;		}	}}