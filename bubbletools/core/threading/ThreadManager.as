// bubbletools.* ===============================================================================// BubbleTools™ Web Application and User Interface Component Architecture for Actionscript 3// ©2007 Michael Szypula.  Any modifications to this file must keep this license block intact.// Developer : Michael Szypula// Contact : michael.szypula@gmail.com// License Information : Contact Developer to obtain license agreement.// =================================================================================================package bubbletools.core.threading {	import bubbletools.core.threading.Thread;	import bubbletools.core.threading.Threaded;	import bubbletools.util.Debug;	public class ThreadManager {		private static var _i:ThreadManager;		private var threads:Array;		private var index:Number;		private var currentThreadId:int;		private var lastAddedThreaded:Array;		private var threadLog:Array;		/*		Thread Syntax		- create a thread in the threadManager using createThread()		- add subsequent items (addToCurrentThread()) to be called when an item completes		- param 1 : Class we are waiting for to finish its operations		- param 2 : Class we are moving control to		- param 3 : Method called in the class from param 2 once it has control.		- Note : Params 1 and 2 must both be extensions of the Threaded superclass		*/		public function ThreadManager() {			index = -1;			currentThreadId = 0;			threads = new Array();			lastAddedThreaded = new Array();			threadLog = new Array();		}		public static function instance():ThreadManager {			if (ThreadManager._i == null) {				ThreadManager._i = new ThreadManager();			}			return ThreadManager._i;		}		public static function log(action:String, show:Boolean):void {			_i.threadLog.push(action);			//show = true;			if (show) {				Debug.output(_i, action);			}		}		public static function displayLog():void {			var actions:Array = _i.threadLog;			for (var i:Number = 0; i < actions.length; i++) {				Debug.output(_i, actions[i]);			}		}		public static function createThread():void {			_i.index++;			_i.currentThreadId = _i.index;			var newThread:Thread = new Thread(_i.index);			_i.threads.push(newThread);		}		public static function setThreadStart(initClass:Threaded, initMethod:Function):void {			var threadStart:Threaded = new Threaded();			threadStart.idName = "THREAD_START";			_i.threads[_i.currentThreadId].addCompleteEvent(threadStart, initClass, initMethod);			_i.lastAddedThreaded[_i.currentThreadId] = initClass;		}		public static function addToCurrentThread(returnClass:Threaded, nextMethod:Function):void {			returnClass.setThreadId(_i.currentThreadId);			_i.threads[_i.currentThreadId].addCompleteEvent(_i.lastAddedThreaded[_i.currentThreadId], returnClass, nextMethod);			_i.lastAddedThreaded[_i.currentThreadId] = returnClass;		}		public static function startThread():void {			_i.threads[_i.currentThreadId].startThread();		}		public function setCurrentThread(id:int):void {			currentThreadId = id;		}		public function getCurrentThreadId():int {			return (currentThreadId);		}		public function terminateThread(id:int):void {			threads[id].terminateThread();		}		public function stepThread(threadId:int):void {			ThreadManager.log("[ThreadManager] stepThread called", false);			if (threads[threadId] != null) {				threads[threadId].stepThread();			} else {				ThreadManager.log("[ThreadManager] no more steps in this thread.", false);			}		}		public function checkCompletion(threadId:int):Boolean {			ThreadManager.log("[ThreadManager] checkCompletion()", false)			if (threads[threadId] != null) {				if (threads[threadId].hasCompleted()) {					return (true);				} else {					return (false);				}			} else {				ThreadManager.log("[ThreadManager] check complete was called on empty thread item, returning TRUE", false);				return (true);			}		}	}}