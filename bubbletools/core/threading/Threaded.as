// bubbletools.* ===============================================================================// BubbleTools™ Web Application and User Interface Component Architecture for Actionscript 3// ©2007 Michael Szypula.  Any modifications to this file must keep this license block intact.// Developer : Michael Szypula// Contact : michael.szypula@gmail.com// License Information : Contact Developer to obtain license agreement.// =================================================================================================package bubbletools.core.threading {		import bubbletools.core.threading.ThreadManager;	public class Threaded implements IThreaded {			private var isComplete:Boolean;		private var returnClasses:Array;		private var returnHandlers:Array;		private var returnHandler:Function;		private var returnClass:IThreaded;		private var threadId:Number;		private var threadQueue:Array;		private var hasQueue:Boolean;				public var idName:String;			public function Threaded() {			ThreadManager.instance();			isComplete = true;			hasQueue = false;			returnClasses = new Array();			returnHandlers = new Array();			threadQueue = new Array();		}		public function setIncomplete():void {			ThreadManager.log("Set Incomplete called - "+idName, false);			isComplete = false;		}		public function getCompletedStatus():Boolean {			return (isComplete);		}		public function setThreadTerminated():void {			ThreadManager.instance().terminateThread(this.threadId);		}		public function setComplete():void {					ThreadManager.log("[Threaded] Set Complete called - "+idName+" (current thread id = "+threadId+")", false);					isComplete = true;			if(threadId < 0) {								ThreadManager.log("[Threaded] Completed item is not being run in a thread.", false);						} else {								ThreadManager.log("[Threaded] Action in thread "+threadId+" completed; stepping thread.", false);				ThreadManager.instance().stepThread(this.threadId);				ThreadManager.log("[Threaded] Checking for completion of thread "+this.threadId, false);								if(ThreadManager.instance().checkCompletion(this.threadId)) {					ThreadManager.log("[Threaded] Thread "+this.threadId+" has completed.", false)					if(hasQueue) {						ThreadManager.log("[Threaded] This class "+this.idName+" has a queue.", false)						ThreadManager.log("[Threaded] Setting this class's thread id to its queued value of "+threadQueue[0], false);						ThreadManager.log("[Threaded] Stepping thread : "+threadQueue[0], false);						this.threadId = threadQueue[0];						ThreadManager.instance().stepThread(threadQueue.shift());					}				}			}		}		public function setThreadId(newThreadId:Number):void {			if(!isNaN(this.threadId)) {				threadQueue.push(this.threadId);				hasQueue = true;			}						this.threadId = newThreadId;						if(hasQueue) {				ThreadManager.log(	"[Threaded] Setting threadId for class "+idName+" to "+this.threadId+									", adding thread "+threadQueue[threadQueue.length-1]+" to queue.", false)			} else {				ThreadManager.log("[Threaded] Setting threadId for class "+idName+" to "+this.threadId+", no threads queued.", false)			}					}		public function resumeOnThread(newThreadId:Number) {			ThreadManager.log("[Threaded] Setting a resume thread id in "+idName+" --> "+newThreadId, false);			this.threadId = newThreadId;		}		public function getThreadId():Number {			if(!isNaN(this.threadId)) {				return (this.threadId);			} else {				return (-1);			}		}		public function setReturnHandler(selectedHandler:Function):void {			returnHandler = selectedHandler;		}		public function addReturnHandler(newHandler:Function):void {			ThreadManager.log("[Threaded] returnHandler added for class "+this.idName+" : "+newHandler, false);			this.returnClasses[returnClasses.length-1].returnHandlers.push(newHandler);		}		public function addReturnClass(returnClass:IThreaded) {			this.returnClasses.push(returnClass);			ThreadManager.log("[Threaded] returnClass added to "+idName+" --> "+returnClass+","+Threaded(returnClass).idName, false);		}		public function getNextWithId(id):Number {						var index:Number;						for (var i:Number=0; i<returnClasses.length;i++) {								ThreadManager.log(	"[Threaded] Class "+idName+" Item "+i+" - thread id of "+									returnClasses[i].idName+" is "+returnClasses[i].getThreadId(), false);								if(returnClasses[i].getThreadId() == id) {					ThreadManager.log("[Threaded] Found next action with thread id : "+id+" at index ="+i, false);					index = i;					break;				}			}			if(isNaN(index)) {				ThreadManager.log("[Threaded] No more actions left with thread id : "+threadId+", checking for lower thread.", false)				if(threadId > 0) {					setThreadId(id-1);					return(getNextWithId(id-1));				} else {					ThreadManager.log("[Threaded] No actions in lower threads, possible error.", false)					return new Number(null);				}			} else {				ThreadManager.log("[Threaded] Returning item "+index+" of returnClasses", false);				return(index);			}		}				public function doNext():void {						ThreadManager.log("[Threaded] Do Next called - length of returnClasses array in "+idName+" ="+this.returnClasses.length, false);						if (this.returnClasses.length>0) {								ThreadManager.log("[Threaded] Resolving next action associated to thread id : "+threadId, false);								var returnIndex:Number = getNextWithId(threadId);								ThreadManager.log(	"[Threaded] Thread "+this.threadId+									" doing next action - passing control to "+returnClasses[returnIndex].idName+" , fn="+									returnClasses[0].returnHandlers[0], false);													returnClass = returnClasses[returnIndex];				returnClasses.splice(returnIndex, 1);								ThreadManager.log("[Threaded] ---> "+Threaded(returnClass).idName, true);								returnClass.setReturnHandler(Threaded(returnClass).returnHandlers.shift());				Threaded(returnClass).returnHandler();			} else {				ThreadManager.log("[Threaded] No next action; end of thread "+this.threadId+" reached.", true);			}		}	}}